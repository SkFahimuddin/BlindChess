<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blind Chess Trainer with Engine</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e293b 0%, #475569 100%);
      min-height: 100vh;
      padding: 20px;
      color: #fff;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-align: center;
    }
    .subtitle {
      text-align: center;
      color: #cbd5e1;
      margin-bottom: 30px;
    }
    .card {
      background: white;
      color: #1e293b;
      border-radius: 12px;
      padding: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      margin-bottom: 20px;
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .btn-primary { background: #3b82f6; color: white; }
    .btn-primary:hover { background: #2563eb; }
    .btn-success { background: #10b981; color: white; }
    .btn-success:hover { background: #059669; }
    .btn-danger { background: #ef4444; color: white; }
    .btn-danger:hover { background: #dc2626; }
    .btn-secondary { background: #64748b; color: white; }
    .btn-secondary:hover { background: #475569; }
    .board-container {
      display: flex;
      justify-content: center;
      margin: 30px 0;
    }
    .chessboard {
      display: inline-block;
      border: 4px solid #1e293b;
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
    }
    .rank {
      display: flex;
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      position: relative;
    }
    .square.light { background: #f0d9b5; }
    .square.dark { background: #b58863; }
    .square.highlight { 
      box-shadow: inset 0 0 0 3px #22c55e;
    }
    .game-info {
      margin-bottom: 20px;
    }
    .turn-indicator {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 15px;
    }
    .move-input-container {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    input[type="text"] {
      flex: 1;
      padding: 12px;
      border: 2px solid #cbd5e1;
      border-radius: 8px;
      font-size: 16px;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #3b82f6;
    }
    .message {
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 15px;
    }
    .message.error {
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #fca5a5;
    }
    .message.success {
      background: #d1fae5;
      color: #065f46;
      border: 1px solid #6ee7b7;
    }
    .move-history {
      border-top: 2px solid #e2e8f0;
      padding-top: 20px;
    }
    .move-history h3 {
      margin-bottom: 10px;
    }
    .history-container {
      background: #f8fafc;
      padding: 15px;
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
    }
    .move-pair {
      display: grid;
      grid-template-columns: 40px 1fr 1fr;
      gap: 10px;
      padding: 5px 0;
    }
    .move-number {
      font-weight: bold;
      color: #64748b;
    }
    .settings {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-top: 15px;
    }
    .setting-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    select {
      padding: 8px 12px;
      border: 2px solid #cbd5e1;
      border-radius: 6px;
      font-size: 14px;
    }
    .info-box {
      background: #1e293b;
      color: white;
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
    }
    .info-box h3 {
      margin-bottom: 10px;
    }
    .info-box ul {
      list-style: none;
      padding-left: 0;
    }
    .info-box li {
      padding: 5px 0;
      color: #cbd5e1;
    }
    label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚ôüÔ∏è Blind Chess Trainer</h1>
    <p class="subtitle">Practice chess against an AI opponent without seeing the board</p>

    <div class="card">
      <div class="controls">
        <button class="btn-primary" onclick="toggleBoard()">
          <span id="boardToggleText">üôà Hide Board</span>
        </button>
        <button class="btn-success" onclick="readMoves()">
          üîä Read Moves
        </button>
        <button class="btn-danger" onclick="newGame()">
          üîÑ New Game
        </button>
        <button class="btn-secondary" onclick="undoMove()">
          ‚Ü∂ Undo
        </button>
      </div>

      <div class="settings">
        <div class="setting-group">
          <label>
            <input type="checkbox" id="speechToggle" checked onchange="toggleSpeech()">
            <span>Text-to-Speech</span>
          </label>
        </div>
        <div class="setting-group">
          <label for="colorSelect">Play as:</label>
          <select id="colorSelect" onchange="setPlayerColor()">
            <option value="white">White</option>
            <option value="black">Black</option>
          </select>
        </div>
        <div class="setting-group">
          <label for="difficultySelect">Difficulty:</label>
          <select id="difficultySelect">
            <option value="0">Beginner (Random)</option>
            <option value="1" selected>Easy (~800)</option>
            <option value="2">Medium (~1200)</option>
            <option value="3">Hard (~1600)</option>
            <option value="4">Expert (~2000)</option>
          </select>
        </div>
      </div>

      <div id="boardContainer" class="board-container">
        <div class="chessboard" id="chessboard"></div>
      </div>

      <div class="game-info">
        <div class="turn-indicator" id="turnIndicator">White to move</div>
        
        <div id="messageBox" class="message hidden"></div>

        <div class="move-input-container">
          <input 
            type="text" 
            id="moveInput" 
            placeholder="Enter move (e.g., e4, Nf3, O-O)" 
            onkeypress="handleKeyPress(event)"
          >
          <button class="btn-primary" onclick="makePlayerMove()">
            ‚û§ Move
          </button>
        </div>
      </div>

      <div class="move-history">
        <h3>Move History</h3>
        <div class="history-container" id="historyContainer">
          <p style="color: #94a3b8;">No moves yet</p>
        </div>
      </div>
    </div>

    <div class="info-box">
      <h3>How to use:</h3>
      <ul>
        <li>‚Ä¢ Enter moves in standard notation: e4, Nf3, Bxc4, O-O</li>
        <li>‚Ä¢ Choose your color and difficulty level</li>
        <li>‚Ä¢ Hide the board to practice truly blind</li>
        <li>‚Ä¢ The AI will respond automatically after your move</li>
        <li>‚Ä¢ Use "Read Moves" to hear the game history</li>
        <li>‚Ä¢ Press Undo to take back the last move</li>
      </ul>
    </div>
  </div>

  <script>
    let chess = new Chess();
    let boardVisible = true;
    let speechEnabled = true;
    let playerColor = 'white';
    let moveHistory = [];
    let lastHighlight = null;

    function initBoard() {
      renderBoard();
      if (playerColor === 'black') {
        setTimeout(makeEngineMove, 500);
      }
    }

    function renderBoard() {
      const board = document.getElementById('chessboard');
      board.innerHTML = '';
      const position = chess.board();
      
      for (let i = 0; i < 8; i++) {
        const rank = document.createElement('div');
        rank.className = 'rank';
        
        for (let j = 0; j < 8; j++) {
          const square = document.createElement('div');
          const isLight = (i + j) % 2 === 0;
          square.className = `square ${isLight ? 'light' : 'dark'}`;
          
          const piece = position[i][j];
          if (piece) {
            const symbols = {
              'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü',
              'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô'
            };
            const symbol = piece.color === 'w' ? symbols[piece.type.toUpperCase()] : symbols[piece.type];
            square.textContent = symbol;
          }
          
          rank.appendChild(square);
        }
        board.appendChild(rank);
      }
    }

    function speakText(text) {
      if (speechEnabled && 'speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.85;
        window.speechSynthesis.speak(utterance);
      }
    }

    function makePlayerMove() {
      const moveInput = document.getElementById('moveInput');
      const moveStr = moveInput.value.trim();
      
      if (!moveStr) return;

      const currentTurn = chess.turn();
      if ((currentTurn === 'w' && playerColor === 'black') || 
          (currentTurn === 'b' && playerColor === 'white')) {
        showMessage("It's not your turn!", 'error');
        return;
      }

      const move = chess.move(moveStr, { sloppy: true });
      
      if (move === null) {
        showMessage('Invalid move! Try again.', 'error');
        speakText('Invalid move');
        return;
      }

      moveInput.value = '';
      updateAfterMove(move);

      if (!chess.game_over()) {
        setTimeout(makeEngineMove, 800);
      }
    }

    function makeEngineMove() {
      if (chess.game_over()) return;

      const difficulty = parseInt(document.getElementById('difficultySelect').value);
      let move;

      if (difficulty === 0) {
        move = getRandomMove();
      } else {
        move = getBestMove(difficulty);
      }

      if (move) {
        const moveObj = chess.move(move);
        updateAfterMove(moveObj);
      }
    }

    function getRandomMove() {
      const moves = chess.moves();
      return moves[Math.floor(Math.random() * moves.length)];
    }

    function getBestMove(depth) {
      const moves = chess.moves();
      let bestMove = null;
      let bestValue = -Infinity;

      for (let move of moves) {
        chess.move(move);
        const value = -minimax(depth - 1, -Infinity, Infinity, false);
        chess.undo();

        if (value > bestValue) {
          bestValue = value;
          bestMove = move;
        }
      }

      return bestMove;
    }

    function minimax(depth, alpha, beta, isMaximizing) {
      if (depth === 0 || chess.game_over()) {
        return evaluateBoard();
      }

      const moves = chess.moves();
      
      if (isMaximizing) {
        let maxEval = -Infinity;
        for (let move of moves) {
          chess.move(move);
          const evaluation = minimax(depth - 1, alpha, beta, false);
          chess.undo();
          maxEval = Math.max(maxEval, evaluation);
          alpha = Math.max(alpha, evaluation);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (let move of moves) {
          chess.move(move);
          const evaluation = minimax(depth - 1, alpha, beta, true);
          chess.undo();
          minEval = Math.min(minEval, evaluation);
          beta = Math.min(beta, evaluation);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    function evaluateBoard() {
      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      let score = 0;

      const board = chess.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece) {
            const value = pieceValues[piece.type];
            score += piece.color === 'w' ? value : -value;
          }
        }
      }

      return chess.turn() === 'w' ? score : -score;
    }

    function updateAfterMove(move) {
      moveHistory.push(move.san);
      renderBoard();
      updateMoveHistory();
      updateTurnIndicator();
      
      const pieceName = getPieceName(move.piece);
      const colorName = move.color === 'w' ? 'White' : 'Black';
      speakText(`${colorName} ${pieceName} to ${move.to}`);

      if (chess.in_checkmate()) {
        const winner = chess.turn() === 'w' ? 'Black' : 'White';
        showMessage(`Checkmate! ${winner} wins!`, 'success');
        speakText(`Checkmate! ${winner} wins!`);
      } else if (chess.in_draw()) {
        showMessage('Game drawn!', 'success');
        speakText('Game drawn');
      } else if (chess.in_check()) {
        showMessage('Check!', 'success');
        speakText('Check');
      }
    }

    function getPieceName(piece) {
      const names = { p: 'pawn', n: 'knight', b: 'bishop', r: 'rook', q: 'queen', k: 'king' };
      return names[piece] || 'piece';
    }

    function updateTurnIndicator() {
      const indicator = document.getElementById('turnIndicator');
      if (chess.game_over()) {
        indicator.textContent = 'Game Over';
      } else {
        const turn = chess.turn() === 'w' ? 'White' : 'Black';
        indicator.textContent = `${turn} to move`;
      }
    }

    function updateMoveHistory() {
      const container = document.getElementById('historyContainer');
      if (moveHistory.length === 0) {
        container.innerHTML = '<p style="color: #94a3b8;">No moves yet</p>';
        return;
      }

      let html = '';
      for (let i = 0; i < moveHistory.length; i += 2) {
        html += `
          <div class="move-pair">
            <span class="move-number">${Math.floor(i/2) + 1}.</span>
            <span>${moveHistory[i]}</span>
            <span>${moveHistory[i + 1] || ''}</span>
          </div>
        `;
      }
      container.innerHTML = html;
      container.scrollTop = container.scrollHeight;
    }

    function showMessage(text, type) {
      const msgBox = document.getElementById('messageBox');
      msgBox.textContent = text;
      msgBox.className = `message ${type}`;
      msgBox.classList.remove('hidden');
      setTimeout(() => msgBox.classList.add('hidden'), 3000);
    }

    function toggleBoard() {
      boardVisible = !boardVisible;
      const container = document.getElementById('boardContainer');
      const toggleText = document.getElementById('boardToggleText');
      
      if (boardVisible) {
        container.classList.remove('hidden');
        toggleText.textContent = 'üôà Hide Board';
      } else {
        container.classList.add('hidden');
        toggleText.textContent = 'üëÅÔ∏è Show Board';
      }
      speakText(boardVisible ? 'Board visible' : 'Board hidden');
    }

    function toggleSpeech() {
      speechEnabled = document.getElementById('speechToggle').checked;
    }

    function setPlayerColor() {
      const select = document.getElementById('colorSelect');
      playerColor = select.value;
      newGame();
    }

    function readMoves() {
      if (moveHistory.length === 0) {
        speakText('No moves yet');
        return;
      }

      let text = 'Move history: ';
      for (let i = 0; i < moveHistory.length; i += 2) {
        text += `${Math.floor(i/2) + 1}. ${moveHistory[i]}`;
        if (moveHistory[i + 1]) {
          text += `, ${moveHistory[i + 1]}. `;
        }
      }
      speakText(text);
    }

    function undoMove() {
      if (moveHistory.length === 0) return;
      
      chess.undo();
      moveHistory.pop();
      
      if (moveHistory.length > 0 && 
          ((chess.turn() === 'w' && playerColor === 'white') || 
           (chess.turn() === 'b' && playerColor === 'black'))) {
        chess.undo();
        moveHistory.pop();
      }

      renderBoard();
      updateMoveHistory();
      updateTurnIndicator();
      showMessage('Move undone', 'success');
      speakText('Move undone');
    }

    function newGame() {
      chess = new Chess();
      moveHistory = [];
      renderBoard();
      updateMoveHistory();
      updateTurnIndicator();
      document.getElementById('moveInput').value = '';
      document.getElementById('messageBox').classList.add('hidden');
      speakText('New game started');
      
      if (playerColor === 'black') {
        setTimeout(makeEngineMove, 500);
      }
    }

    function handleKeyPress(event) {
      if (event.key === 'Enter') {
        makePlayerMove();
      }
    }

    initBoard();
  </script>
</body>
</html>